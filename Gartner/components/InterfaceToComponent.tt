<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.ObjectModel" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ output extension=".txt" #>

<#@include file="$(ProjectDir)\..\Gartner.CPP.Core.Orchestrator.Interfaces\Manager.ttinclude" #>

<#	
	 
	var directory = Host.ResolvePath("");
	var directoryRenders = directory + "\\componentRenders";
	directory = directory.Replace("Web\\Scripts\\react\\components","Gartner.CPP.Core.Orchestrator.Interfaces") + @"\InterfaceDefinitions";
	var files = Directory.GetFiles(directory,"*.xml");
	XmlSerializer serializer = new XmlSerializer(typeof(InterfaceTemplate));
	  
	var host = this.Host;
	var manager = Manager.Create(host, GenerationEnvironment);

	foreach(string file in files)
	{     
		using (Stream reader = new FileStream(file,FileMode.Open))
		{ 
			var interfaceDefinition = (InterfaceTemplate)serializer.Deserialize(reader);

			if (interfaceDefinition.React == null) interfaceDefinition.React = new ReactClassDetail();

			if (interfaceDefinition.React.GenerateComponent != "true" )
            {
				continue;
            } 

			manager.StartNewFile(file.Replace(".xml",".tsx").Replace("I" + interfaceDefinition.Name,interfaceDefinition.Name).Replace("Gartner.CPP.Core.Orchestrator.Interfaces","Web\\Scripts\\react\\components").Replace(@"\InterfaceDefinitions","")); 
#>
import * as React from 'react';
import * as ReactDom from 'react-dom';
import { connect } from 'react-redux';
import * as actions from '../actions/genericActions';
import { ComponentDescriptor } from '../models/generic';
import ComboBox from './kendo/ComboBox';
import HelpButton from './HelpButton';
import { Input, FormGroup, TextArea, Label } from './Form';
<# 
	WriteLine(ReactComponentHelper.GetImportStatements(interfaceDefinition));
#>

export interface <#=interfaceDefinition.Name#>Props {
    getComponentData: (component: Object) => void;
    <#=interfaceDefinition.Name#>: Object;
    componentDescriptor: ComponentDescriptor;   
	updateState: Function;
	<#if(interfaceDefinition.React.EventEmitterFunction != null) {
		WriteLine(interfaceDefinition.Name + "Refresh: () => void;");
	}#>
}


<#=ReactComponentHelper.GetEventEmitterFunction(interfaceDefinition)#>

export const <#=interfaceDefinition.Name#>Component = React.createClass<<#=interfaceDefinition.Name#>Props, any>({

componentWillMount() {
	this.componentDescriptor = {
		name: '<#=interfaceDefinition.Name#>',	
		returnObjectIndexed: <#=interfaceDefinition.React.ReturnObjectIndexed#>,
		dataDictionary: {
			<# 
			var firstTimeThroughComponentWillMount = true;
			foreach(Property propDetail in interfaceDefinition.Properties)
        {	
			var valueToUse = "''";
			if(propDetail.Name =="ID") valueToUse = "'0'";
	
			if(propDetail.React.DataDictionaryExclude != true) {if(!firstTimeThroughComponentWillMount){#>,<#}#><#=(string.IsNullOrEmpty(propDetail.DisplayName)?propDetail.Name:propDetail.DisplayName)#>: <#=valueToUse#><#firstTimeThroughComponentWillMount = false;}}#>
		}
	}

		<#WriteLine(ReactComponentHelper.GetDataDictionaryPopulator(interfaceDefinition, "componentWillMount",""));#>

        this.props.componentData(this.componentDescriptor, 'GetData');


	<#if(interfaceDefinition.React.EventEmitterListeners != null) {	
		foreach(var eeListener in interfaceDefinition.React.EventEmitterListeners){   
			if(eeListener != null) {				
				if(!string.IsNullOrEmpty(eeListener.Name)) {
			#>
		this.props.eventEmitter.addListener('<#=eeListener.Name#>', <#=eeListener.Name#>);
			<#	
				}				
			}
		}
	}#>    

},

<#foreach(ReactClassFunction classFunction in interfaceDefinition.React.Functions)
{

	if(!string.IsNullOrEmpty(classFunction.Parameters))
	{#>

		<#=classFunction.Name#> (<#=classFunction.Parameters#>: any) 
		{
			if (<#=classFunction.Parameters#> != '') 
			{
<#}else{#>
<#=classFunction.Name#>()
{
<#}#>
		
		<#
	if(interfaceDefinition.React.ComponentType == "Bench") 
    {
		foreach(Property propDetail in interfaceDefinition.Properties)
		{   
			ReactPropertyFunction currentPropFunction = (ReactPropertyFunction) propDetail.React.Functions.FirstOrDefault(x => x.Name == classFunction.Name);
			if(currentPropFunction == null) continue;

			if(!string.IsNullOrEmpty(currentPropFunction.Value)) 
			{
			#>this.componentDescriptor.dataDictionary["<#=propDetail.Name#>"] = <#=currentPropFunction.Value#>;
			<#}
			else{#>this.componentDescriptor.dataDictionary["<#=propDetail.Name#>"] = this.props.<#=interfaceDefinition.Name#>.<#=propDetail.Name#>.Value;
			<#}
		}
    }
		WriteLine(ReactComponentHelper.GetDataDictionaryPopulator(interfaceDefinition, classFunction.Name, classFunction.Parameters));

		if(!string.IsNullOrEmpty(classFunction.Action)){#>
		this.props.componentData(this.componentDescriptor, '<#=classFunction.Action#>');
		<#}
		if(interfaceDefinition.React.EventEmitterSubscribers != null){	
		foreach(var eeSubscriber in interfaceDefinition.React.EventEmitterSubscribers){   
			if(eeSubscriber != null){							 
				if(!string.IsNullOrEmpty(eeSubscriber.Name)){
			#>
	this.props.eventEmitter.emitEvent('<#=eeSubscriber.Name#>', <#=eeSubscriber.Parameter#>);
			<#	
				}				
			}
		}
	}
	#>  
	<#if(!string.IsNullOrEmpty(classFunction.Parameters)) WriteLine("}");#>
},
	<#
  
}
		var fileName = directoryRenders + "\\" + interfaceDefinition.Name + "Functions.tsxFunctions";
		if(File.Exists(fileName)) {
			var functionsFile = File.ReadAllText(fileName);
			this.Write(functionsFile);
        }

		if(interfaceDefinition.React.ComponentType == "SimpleText") {
		#>
		handleChange(e) {
        this.props.updateState(this.componentDescriptor, e.target.id, e.target.value);
    },
	<#}#>

render() {
const <#=interfaceDefinition.Name#> = this.props.<#=interfaceDefinition.Name#>;
<#if(!string.IsNullOrEmpty(interfaceDefinition.React.AddConst)) {#>
const <#=interfaceDefinition.React.AddConst#>
<#}#>



return (
			<# 
				var contents = File.ReadAllText(directoryRenders + "\\" + interfaceDefinition.Name + "Render.tsxRender");
				this.Write(contents);
			#>
	);
}
});

	const mapStateToProps = (state) => {
    if (!state.<#=interfaceDefinition.Name#>) {
		const { itemId } = state;

        return {
			itemId: state.itemId,
			<#if(interfaceDefinition.React.HasEventEmitters()) {	#>
			eventEmitter: state.eventEmitter,
			<#}#>
            <#=interfaceDefinition.Name#>: [{
			
			<#
			var firstTimeThrough = true;
			foreach(Property propDetail in interfaceDefinition.Properties)
        {  
			if(!string.IsNullOrEmpty(propDetail.React.MapStateToPropsValue)) {
				if (!firstTimeThrough) {#>,<#}#><#=(string.IsNullOrEmpty(propDetail.DisplayName)?propDetail.Name:propDetail.DisplayName)#>: {	Value: <#=propDetail.React.MapStateToPropsValue#> }
			<#
				firstTimeThrough = false;
				}
			}#>
        }]
        };
    }

	 return {
		<#if(interfaceDefinition.React.HasEventEmitters()) {	#>
		eventEmitter: state.eventEmitter,
		<#}#>
		itemId: state.itemId,
        <#=interfaceDefinition.Name#>: state.<#=interfaceDefinition.Name#>
    };
};

export const <#=interfaceDefinition.Name#>Container =
    connect(
        mapStateToProps,
        actions
    )(<#=interfaceDefinition.Name#>Component) as React.ClassicComponentClass<any>;


export default <#=interfaceDefinition.Name#>Component;

<#		} 
		manager.EndBlock();
	} 
	manager.Process(true); 
#>
<#@include file="ReactComponentHelper.ttinclude" #>